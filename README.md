# RPlatform

Arduino-библиотека для управления РОББО Платформой.

## Установка

### Через менеджер библиотек

Этот способ предпочтительнее, потому что Arduino IDE самостоятельно будет следить за обновлениями библиотеки и предложит их загрузить.

Откройте **Arduino IDE**. Откройте **Менеджер библиотек**. Для этого выберите пункт меню **Инструменты - Управлять библиотеками** или нажмите комбинацию клавиш <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>I</kbd>. В появившемся окне наберите в строке поиска название библиотеки и нажмите кнопку **Установка**. Через некоторое время последняя версии библиотеки будет загружена и установлена.

### Установка с помощью zip-архива

Если на компьютере нет доступа в интернет, нужно использовать этот способ.

По ссылке перейдите на [страницу релиза последней версии](https://github.com/skyfroger/RPlatform/releases/latest). В разделе **Assets** скачайте архив с названием **Source code (zip)**. Файл будет называться **RPlatform-[версия].zip**.

> Перед установкой новой версии библиотеки из zip-файла, удалите предыдущую версию!

Откройте **Arduino IDE**. Выберите пункт меню **Скетч - Подключить библиотеку - Добавить .ZIP библиотеку...** . В появившемся диалоговом окне выберите сохранённый ранее архив.

Перезапустите **Arduino IDE**.

Библиотека установлена.

## Примеры скетчей

Примеры можно найти в меню **Файл - Примеры - RPlatform**.

## Подключение

Для импорта библиотеки в скетч, нужно добавить в начале следующую строку:

```c++
#include <RPlatform.h>
```

Добавить эту строку можно вручную или с помощью меню **Скетч - Подключить библиотеку - RPlatform**.

## Документация

Перед тем, как обращаться к методам, нужно создать объект класса `RPlatform`:

```c++
#include <RPlatform.h> // подключение библиотеки

// объект класса RPlatform создаётся вне функции setup() и loop()
RPlatform robot;

void setup(){
    // начальная настройка
}

void loop(){
    // главыный цикл Arduino-скетча
}
```

### Чтение показаний датчика

```c++
int readSensor(int portNumber, bool raw = false);
```

Функция возвращает показания датчика в слоте с номером `portNumber`. Значение показаний находятся в диапазоне *0..100*. Если вторым аргументом передать значение `true`, то функция вернёт *сырое* значение (*0..1023*).

Пример:

```c++
int sensor = robot.readSensor(1); // данные с датчика на первой позиции
int rawData = robot.readSensor(2, true); // сырые данные с датчика на второй позиции
```

### Кнопка START

```c++
bool isStartPressed();
```

Функция возвращает `true`, если кнопка START нажата, иначе возвращается `false`.

Пример:

```c++
// цикл выполняется, пока кнопка не нажата
while(!robot.isStartPressed()) {}
```

С помощью такого цикла можно остановить программу до нажатия на кнопку START.

### Включение и выключение светодиода

К слоту можно подключить модуль со светодиодом. Чтобы включать и выключать светодиод в заданном слоте, используются следующие функции:

```c++
void ledOn(int portNumber); // включение
void ledOff(int portNumber); // выключение
```

`portNumber` - номер слота к которому подключен светодиод.

Пример:

```c++
// мигание светодиодом, подключенным к слоту 3
void loop(){
    robot.ledOn(3); // включение светодиода
    delay(1000); // пауза в 1 секунду
    robot.ledOff(3); // выключение светодиода
    delay(1000); // пауза в 1 секунду
}
```

### Мощность моторов

```c++
void setPower(int power);
void setPower(int powerL, int powerR);
```

С помощью функции можно изменить мощность, как обоих моторов одновременно, так и по отдельности. Значение мощности указывается в диапазоне *0..100*. Если указать значение, которое выходит за диапазон, то оно будет приведено к ближайшему допустимому - *0* или *100*.

Пример:

```c++
robot.setPower(40); // мощность обоих моторов - 40
robot.setPower(5, 30); // левый мотор - 5, правый мотор - 30
```

### Направление вращения моторов

```c++
void setDirection(direction dir);
void setDirection(direction dirL, direction dirR);
```

Функция задаёт направление вращения моторов. В качестве аргументов передаются два возможных значения-константы:

```c++
FW // движение вперёд (forward)
BW // движение назад (backward)
```

Пример:

```c++
robot.setDirection(FW); // направление обоих двигателей - "вперёд"
robot.setDirection(BW); // направление обоих двигателей - "назад"
robot.setDirection(BW, FW); // левый двигатель - "назад", правый двигатель - "вперёд"
```

### Одновременная настройка мощности и направления вращения

```c++
void setRunSettings(direction dirL, direction dirR, int powerL, int powerR);
```

Функция позволяет изменить направление вращения левого двигателя `dirL` и правого двигателя `dirR`, а также мощность левого двигателя `powerL` и правого двигателя `powerR`.

Пример:

```c++
/*
Направление обоих двигателей - "вперёд"
Мощность левого мотора - 10
Мощность правого мотора - 20
*/
robot.setRunSettings(FW, FW, 10, 20);

/*
Направление левого двигателя - "назад"
Направление правого двигателя - "вперёд"
Мощность обоих двигателей - 35
*/
robot.setRunSettings(BW, FW, 35, 35);
```

### Запуск и остановка моторов

```c++
void run(); // запуск моторов
```

```c++
void stop(); // остановка моторов
```

Моторы работают до тех пор, пока не будут остановлены функцией `stop()`.

Пока моторы запущены, можно менять их мощность и направление вращения. Изменения сразу будут отражаться на поведении платформы.

### Запуск моторов на определённое время

```c++
void runTime(float seconds);
```

Функция запустит двигатели на `seconds` секунд.

Пример:

```c++
robot.setDirection(FW); // направление движения - "вперёд"
robot.setPower(20); // мощность - 20

// Платформа будет ехать прямо 4 секунды
robot.runTime(4);

robot.setDirection(BW); // направление движения - "назад"
// Платформа будет ехать назад пол секунды
robot.runTime(0.5);
```

### Запуск моторов на определённое количество шагов

```c++
void runSteps(int steps);
void runSteps(int leftSteps, int rightSteps);
```

Функция запускает двигатели на `steps` шагов.

Можно указать различное количество шагов для левого (`leftSteps`) и правого (`rightSteps`) колёс.

> Полный оборот колеса приблизительно занимает 24 шага.

Пример:

```c++
robot.runSteps(200); // запуск обоих колёс платформы на 200 шагов
robot.runSteps(24, 100); // левое колесо - 24 шага, правое - 100
```

### Количество шагов. Сброс счётчиков шагов

Количество шагов для левого и правого моторов можно получить с помощью этих функций:

```c++
int getLeftSteps(); // количество шагов слева
int getRightSteps(); // количество шагов справа
```

Пример:

```c++
int left = robot.getLeftSteps();
int right = robot.getRightSteps();
```

Стартовое значения для счётчиков - *0*. В программе может понадобиться сбросить значения счётчиков до нуля. Для этого используется следующая функция:

```c++
void resetSteps();
```

Пример:

```c++
// начальное значение для количества шагов = 0
robot.runSteps(25);
int left = robot.getLeftSteps(); // left = 25
robot.runSteps(10);
left = robot.getLeftSteps(); // left = 35
robot.resetSteps(); // сброс счётчиков
robot.runSteps(15);
left = robot.getLeftSteps(); // left = 15
```

### Запуск моторов на определённый угол поворота

```c++
void runAngle(int angle);
void runAngle(int leftAngle, int rightAngle);
```

С помощью функции можно указать на какой угол должны повернуться оба колеса платформы или задать угол поворота для каждого колеса отдельно.

Пример:

```c++
robot.runAngle(180); // оба колёса повернутся на 180 градусов и платформа остановится
robot.runAngle(120, 60); // левое колесо - 120 градусов, правое колесо - 60 градусов
```

### Поворот платформы на указанный угол

```c++
void turnLeft(int angle); // поворот налево
```

```c++
void turnRight(int angle); // поворот направо
```

Платформа повернётся на угол `angle` в нужную сторону.

> Чем больше угол поворота, тем меньше его точность. Лучше не использовать данные функции для поворота платформы на угол больше 180 градусов. Накапливаемая ошибка становится слишком большой.

Пример:

```c++
robot.turnRight(45); // поворот платформы на 45 градусов вправо
robot.turnLeft(100); // поворот платформы на 100 градусов влево
```

После поворота, функция восстановит установленное до её вызова направление вращения колёс платформы.

```c++
robot.setDirection(BW); // направление движения - назад
robot.runTime(2); // движение назад в течении 2 секунд
robot.turnRight(45); // поворот направо на 45 градусов
robot.runTime(2); // платформа опять поедет назад 
```

### Альтернативное управление движением

Описанные выше функции для управления мощностью моторов и направлением вращения колёс, в определённой степени, повторяют блоки из RobboScratch. Для тонкой настройки движения также можно использовать следующую функцию:

```c++
void move(int leftPower, int rightPower); // запуск моторов с указанной мощностью
void move(int leftPower, int rightPower, float timeSec); // запуск на указанное время
void move(int leftPower, int rightPower, int leftAngle, int rightAngle); // запуск на указанный угол
```

Параметры мощности `leftPower` и `rightPower` могут изменяться в диапазоне от *-100* до *100*. Положительное значение указывает на движение вперёд, отрицательное значение - на движение назад.

Параметры угла поворота `leftAngle` и `rightAngle` также могут быть положительными и отрицательными. Знак числа также влияет на направление вращения колеса. Направление вращения колеса в зависимости от знака мощности и угла поворота показана в следующей таблице:

|                            | Положительный угол (+) | Отрицательный угол (-) |
| -------------------------- | ---------------------- | ---------------------- |
| Положительная мощность (+) | вперёд                 | назад                  |
| Отрицательная мощность (-) | назад                  | вперёд                 |

Примеры:

```c++
robot.move(30, 30); // движение вперёд с можностью 30 без остановки
robot.move(-35, 35); // вращение на месте с поворотом налево
robot.move(40, 20, 2.5); // плавный поворот направо в течении 2.5 секунд
robot.move(50, -50, 180, -180); // движение вперёд (см. таблицу выше)
```

## Загрузка скетча через Arduino IDE

Подключите Платформу к компьютеру и запустите Arduino IDE. В меню **Инструменты** - **Плата** выберите *Arduino Nano*.

В меню **Порт** выберите последовательный порт, к которому подключена Платформа (один из COM-портов).

Выберите пункт *ATmega328P (Old bootloader)* в меню **Инструменты** - **Процессор**.

Теперь скетч можно загрузить в Платформу. Программа начнёт выполняться почти сразу после подачи питания. Чтобы запускать программу по нажатию на кнопку *START*, поместите в функции `setup()` цикл `while`, который прекратит работу после нажатия кнопки и позволит программе выполняться дальше.

```cpp
setup(){
    // цикл выполняется, пока не нажата кнопка START
    while(!robot.isStartPressed()) {}
    delay(3000); // задержка 3 секунды
}
```
